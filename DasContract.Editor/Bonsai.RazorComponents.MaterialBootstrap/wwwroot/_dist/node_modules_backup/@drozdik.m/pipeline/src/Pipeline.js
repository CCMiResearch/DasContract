exports.__esModule = true;
var PipelineStates_1 = require("./PipelineStates");
var Observer_1 = require("./Observer/Observer");
var ObserverType_1 = require("./Observer/ObserverType");
var Pipeline = /** @class */ (function () {
    /**
     * Constructs a new pipeline.
     * @param executor Executor function that calls rejector or resolver on any a/sync operations finish
     */
    function Pipeline(executor) {
        //Executor
        this.executor = null;
        //Observers
        this.observers = [];
        this.observerServiced = 0;
        //Result and error
        this.result = [];
        //State
        this.state = PipelineStates_1.PipelineState.Inactive;
        this.executor = executor;
        this.Resolve = this.Resolve.bind(this);
        this.Reject = this.Reject.bind(this);
        this.Execute();
    }
    /**
     * Executes executor and changes pipeline state
     * @param resolve Resolver (called on success)
     * @param reject Rejector (called on error)
     */
    Pipeline.prototype.Execute = function (resolve, reject) {
        if (resolve === void 0) { resolve = this.Resolve; }
        if (reject === void 0) { reject = this.Reject; }
        if (this.state != PipelineStates_1.PipelineState.Inactive)
            return;
        this.state = PipelineStates_1.PipelineState.Waiting;
        this.executor(resolve, reject);
    };
    /**
     * Callback for success async operations
     * @param results Results
     */
    Pipeline.prototype.Resolve = function () {
        var result = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            result[_i] = arguments[_i];
        }
        //Change pipeline state
        this.state = PipelineStates_1.PipelineState.Resolved;
        //Save the result
        this.SetResult(result);
        //Call observers
        for (var i = this.observerServiced; i < this.observers.length; i++) {
            //Update serviced observers
            this.observerServiced = i;
            //Skip catchers
            if (this.observers[i].GetType() == ObserverType_1.ObserverType.Catcher)
                continue;
            //Call current observer
            var res = this.HandleObserverFunction(this.observers[i].GetFunction());
            if (res instanceof Pipeline) {
                this.observerServiced += 1;
                break;
            }
        }
    };
    /**
     * Callback for error async operations
     * @param results Results
     */
    Pipeline.prototype.Reject = function (error) {
        //Change pipeline state
        this.state = PipelineStates_1.PipelineState.Rejected;
        //Save the result
        this.SetResult(error);
        //Call observers
        for (var i = this.observerServiced; i < this.observers.length; i++) {
            //Update serviced observers
            this.observerServiced = i;
            //Skip catchers
            if (this.observers[i].GetType() == ObserverType_1.ObserverType.Runner)
                continue;
            //Call current observer
            var res = this.HandleObserverFunction(this.observers[i].GetFunction());
            if (res instanceof Pipeline) {
                this.observerServiced += 1;
                break;
            }
        }
    };
    /**
     * Handles running and responsing to observer function
     * @param observerFunction Observer function
     */
    Pipeline.prototype.HandleObserverFunction = function (observerFunction) {
        var observerResult = observerFunction.apply(this, this.result);
        //The result is another pipeline
        if (observerResult instanceof Pipeline) {
            //Subscribe to recured pipeline
            var returnedPipeline = observerResult;
            var object_1 = this;
            this.state = PipelineStates_1.PipelineState.Waiting;
            returnedPipeline.Then(function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                setTimeout(function () {
                    object_1.Resolve.apply(object_1, data);
                }, 0);
            }).Catch(function (error) {
                setTimeout(function () {
                    object_1.Reject.apply(object_1, [error]);
                }, 0);
            });
        }
        //The result is a value, pass it
        else
            this.SetResult(observerResult);
        return observerResult;
    };
    /**
     * Sets new value to pass to the next observer
     * @param newValue The new value
     */
    Pipeline.prototype.SetResult = function (newValue) {
        if (newValue instanceof Array)
            this.result = newValue;
        else
            this.result = [newValue];
    };
    /**
     * Runs code after previous sync/async pipeline/observer finished
     * @param observerFunction Observer function to run
     */
    Pipeline.prototype.Then = function (observerFunction) {
        //Add observer to the queue
        if (this.state == PipelineStates_1.PipelineState.Waiting || this.state == PipelineStates_1.PipelineState.Inactive)
            this.observers.push(new Observer_1.Observer(observerFunction, ObserverType_1.ObserverType.Runner));
        //Executor already resolved
        else if (this.state == PipelineStates_1.PipelineState.Resolved)
            this.HandleObserverFunction(observerFunction);
        //Executor errored
        //else if (this.state == PipelineState.Rejected) 
        return this;
    };
    /**
     * Runs code when this pipeline is rejected
     * @param catcherFunction Catcher function to run
     */
    Pipeline.prototype.Catch = function (catcherFunction) {
        //Add observer to the queue
        if (this.state == PipelineStates_1.PipelineState.Waiting || this.state == PipelineStates_1.PipelineState.Inactive)
            this.observers.push(new Observer_1.Observer(catcherFunction, ObserverType_1.ObserverType.Catcher));
        //Executor already resolved
        //else if (this.state == PipelineState.Resolved)
        //Executor errored
        else if (this.state == PipelineStates_1.PipelineState.Rejected)
            this.HandleObserverFunction(catcherFunction);
        return this;
    };
    /**
     * Creates rejected pipeline base on an error
     * @param error The error
     */
    Pipeline.Reject = function (error) {
        return new Pipeline(function (resolve, reject) {
            reject(error);
        });
    };
    /**
     * Creates resolved pipeline that returns a result
     * @param result The result to return
     */
    Pipeline.Resolve = function () {
        var result = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            result[_i] = arguments[_i];
        }
        return new Pipeline(function (resolve, reject) {
            if (result.length == 1)
                resolve(result[0]);
            else
                resolve(result);
        });
    };
    return Pipeline;
}());
exports.Pipeline = Pipeline;
