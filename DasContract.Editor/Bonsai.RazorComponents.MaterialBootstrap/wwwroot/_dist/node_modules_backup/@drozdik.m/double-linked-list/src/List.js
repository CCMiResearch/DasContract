exports.__esModule = true;
var ListNode_1 = require("./ListNode");
var ListIterator_1 = require("./ListIterator");
var comparator_handler_1 = require("@drozdik.m/comparator-handler");
//--------------------------------------------------
//----------LIST------------------------------------
//--------------------------------------------------
var List = /** @class */ (function () {
    //(back)item---item---item---item(front)
    //--------------------------------------------------
    //---------CONSTRUCTOR------------------------------
    //--------------------------------------------------
    /**
     * Creates new instance of List.
     * @param items Initial items in the List.
     * @param comparator Comparator for search functions. It automatically detects IComparable classes.
     */
    function List(items, comparator) {
        if (items === void 0) { items = []; }
        if (comparator === void 0) { comparator = null; }
        //--------------------------------------------------
        //----------VARIABLES-------------------------------
        //--------------------------------------------------
        this.count = 0;
        this.front = null;
        this.back = null;
        this.comparator = null;
        for (var i = 0; i < items.length; i++)
            this.Insert(items[i]);
        this.comparator = new comparator_handler_1.ComparatorHandler(comparator);
    }
    //--------------------------------------------------
    //----------ITERATOR--------------------------------
    //--------------------------------------------------
    List.prototype.First = function () {
        return new ListIterator_1.ListIterator(this.back);
    };
    List.prototype.Last = function () {
        return new ListIterator_1.ListIterator(this.front);
    };
    //--------------------------------------------------
    //----------COUNT-----------------------------------
    //--------------------------------------------------
    List.prototype.Count = function () {
        return this.count;
    };
    List.prototype.IsEmpty = function () {
        return this.Count() == 0;
    };
    //--------------------------------------------------
    //----------CLEARS----------------------------------
    //--------------------------------------------------
    List.prototype.Dispose = function () {
        this.count = -1;
        this.front = null;
        this.back = null;
        this.comparator.Dispose();
    };
    List.prototype.Clear = function () {
        this.count = 0;
        this.front = null;
        this.back = null;
    };
    //--------------------------------------------------
    //----------INDEXES---------------------------------
    //--------------------------------------------------
    List.prototype.AtIterator = function (index) {
        var curr = this.back;
        for (var i = 0; i < index; i++) {
            //Return "not found"
            if (curr == null)
                return new ListIterator_1.ListIterator(null);
            //Move
            curr = curr.next;
        }
        return new ListIterator_1.ListIterator(curr);
    };
    List.prototype.At = function (index) {
        var res = this.AtIterator(index);
        if (res == null)
            return null;
        return res.Value();
    };
    //--------------------------------------------------
    //----------CLONE-----------------------------------
    //--------------------------------------------------
    List.prototype.Clone = function () {
        var resArr = [];
        for (var it = this.First(); it.HasValue(); it.Next()) {
            if (it.Value() != null) {
                if (typeof it.Value().Clone != "undefined")
                    resArr.push(it.Value().Clone());
                else
                    resArr.push(it.Value());
            }
            else
                resArr.push(null);
        }
        var res = new List(resArr);
        res.comparator = this.comparator.Clone();
        return res;
    };
    //--------------------------------------------------
    //----------FIND------------------------------------
    //--------------------------------------------------
    List.prototype.Find = function (item) {
        for (var it = this.First(); it.HasValue(); it.Next()) {
            if (this.comparator.Compare(it.Value(), item) == 0)
                return new ListIterator_1.ListIterator(it.GetCurrentNode());
        }
        return new ListIterator_1.ListIterator(null);
    };
    //--------------------------------------------------
    //----------UPDATE----------------------------------
    //--------------------------------------------------
    List.prototype.UpdateAt = function (newValue, iterator) {
        iterator.GetCurrentNode().value = newValue;
    };
    List.prototype.Update = function (oldValue, newValue) {
        var it = this.Find(oldValue);
        if (it != null)
            it.GetCurrentNode().value = newValue;
    };
    //--------------------------------------------------
    //----------INSERT----------------------------------
    //--------------------------------------------------
    List.prototype.Insert = function (item) {
        this.InsertFront(item);
    };
    /**
    * Adds first node - O(1)
    * @param value Value to add
    */
    List.prototype.AddFirst = function (value) {
        //Create new node
        var newNode = new ListNode_1.ListNode(value);
        //Add it
        this.front = newNode;
        this.back = newNode;
        this.count++;
    };
    /**
     * Inserts a node after position selected by the iterator - O(1)
     * @param value Value to add
     * @param iterator Position iterator
     */
    List.prototype.InsertAfter = function (value, iterator) {
        //Nulls
        if (iterator == null)
            return;
        var addAfterNode = iterator.GetCurrentNode();
        if (addAfterNode == null)
            return;
        //New nodes next
        var newNodesNext = null;
        if (addAfterNode.next != null)
            newNodesNext = addAfterNode.next;
        //New nodes previous
        var newNodesPrevious = addAfterNode;
        //New node
        var newNode = new ListNode_1.ListNode(value, newNodesNext, newNodesPrevious);
        //Redirect pointers to the new node
        addAfterNode.next = newNode;
        if (newNodesNext != null)
            newNodesNext.previous = newNode;
        //Change "back" if new node is the last one
        if (newNode.next == null)
            this.front = newNode;
    };
    /**
     * Inserts a node before position selected by iterator - O(1)
     * @param value Value to add
     * @param iterator Position iterator
     */
    List.prototype.InsertBefore = function (value, iterator) {
        //Nulls
        if (iterator == null)
            return;
        var addBeforeNode = iterator.GetCurrentNode();
        if (addBeforeNode == null)
            return;
        //New nodes next
        var newNodesNext = addBeforeNode;
        //New nodes previous
        var newNodesPrevious = null;
        if (addBeforeNode.previous != null)
            newNodesPrevious = addBeforeNode.previous;
        //New node
        var newNode = new ListNode_1.ListNode(value, newNodesNext, newNodesPrevious);
        //Redirect pointers to the new node
        addBeforeNode.previous = newNode;
        if (newNodesPrevious != null)
            newNodesPrevious.next = newNode;
        //Change "back" if new node is the last one
        if (newNode.previous == null)
            this.back = newNode;
    };
    /**
     * Adds an element to the front - O(1)
     * @param value Value to save
     */
    List.prototype.InsertFront = function (value) {
        //If there is 0 elements
        if (this.IsEmpty()) {
            this.AddFirst(value);
            return;
        }
        //Create new element
        var newNode = new ListNode_1.ListNode(value, null, this.front);
        //Redirect front element
        this.front.next = newNode;
        //Change front to the new node
        this.front = newNode;
        //Increase size
        this.count += 1;
    };
    /**
     * Adds an element to the back - O(1)
     * @param value Value to save
     */
    List.prototype.InsertBack = function (value) {
        //If there is 0 elements
        if (this.IsEmpty()) {
            this.AddFirst(value);
            return;
        }
        //Create new element
        var newNode = new ListNode_1.ListNode(value, this.back, null);
        //Redirect back element
        this.back.previous = newNode;
        //Change back to the new node
        this.back = newNode;
        //Increase size
        this.count += 1;
    };
    //--------------------------------------------------
    //----------REMOVE----------------------------------
    //--------------------------------------------------
    List.prototype.RemoveAt = function (iterator) {
        //Nulls
        if (iterator == null)
            return;
        var elementToRemove = iterator.GetCurrentNode();
        if (elementToRemove == null)
            return;
        //Corrent back and front
        if (this.back == elementToRemove)
            this.back = elementToRemove.next;
        if (this.front == elementToRemove)
            this.front = elementToRemove.previous;
        //Redirect previous element
        if (elementToRemove.previous != null)
            elementToRemove.previous.next = elementToRemove.next;
        //Redirect next element
        if (elementToRemove.next != null)
            elementToRemove.next.previous = elementToRemove.previous;
        this.count -= 1;
    };
    List.prototype.Remove = function (item) {
        this.RemoveAt(this.Find(item));
    };
    //--------------------------------------------------
    //----------BUILD-----------------------------------
    //--------------------------------------------------
    List.prototype.Build = function (items) {
        for (var i = 0; i < items.length; i++)
            this.InsertFront(items[i]);
    };
    return List;
}());
exports.List = List;
