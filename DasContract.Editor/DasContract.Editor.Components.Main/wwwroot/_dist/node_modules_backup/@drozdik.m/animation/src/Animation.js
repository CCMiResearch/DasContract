exports.__esModule = true;
var lerp_1 = require("@drozdik.m/lerp");
var event_1 = require("@drozdik.m/event");
var AnimationArgs_1 = require("../args/AnimationArgs");
var Animation = /** @class */ (function () {
    //--------------------------------------------------
    //----------CONSTRUCTOR-----------------------------
    //--------------------------------------------------
    /**
     * Controller for handling lerp functions
     * @param from Value to animate from
     * @param to Value to animate to
     * @param duration Duration of the animation [ms]
     * @param easing Easing/lerp function
     */
    function Animation(duration, easing) {
        if (duration === void 0) { duration = 250; }
        if (easing === void 0) { easing = lerp_1.EaseOutCubic; }
        //Tech settings
        this.currentFrame = 0;
        this.fps = 75;
        this.frameTimeout = -1;
        //Events
        this.OnStart = new event_1.Event();
        this.OnRender = new event_1.Event();
        this.OnFrame = new event_1.Event();
        this.OnEnd = new event_1.Event();
        this.duration = duration;
        this.easing = easing;
    }
    //--------------------------------------------------
    //----------CONTROLS--------------------------------
    //--------------------------------------------------
    /**
     * Invokes Stop and starts playing the animation
     * @param from Initial value
     * @param to Target value
     */
    Animation.prototype.StopAndStart = function (from, to) {
        this.Stop();
        return this.Start(from, to);
    };
    /**
     * Plays an animation
     * @param from Initial value
     * @param to Target value
     */
    Animation.prototype.Start = function (from, to) {
        var object = this;
        var totalFrames = (object.duration / 1000) * object.fps;
        var framesDelay = 1000 / object.fps;
        //let framesAddition = totalFrames / object.fps;
        this.from = from;
        this.to = to;
        //Start event
        this.OnStart.Invoke(this, new AnimationArgs_1.AnimationArgs(from));
        this.OnRender.Invoke(this, new AnimationArgs_1.AnimationArgs(from));
        var animationFrame = function () {
            //Calculate interpolation value
            object.currentFrame += 1;
            var interpolationValue = object.easing(from, to, object.currentFrame, totalFrames);
            //Continue
            if (object.currentFrame < totalFrames)
                object.frameTimeout = setTimeout(animationFrame, framesDelay);
            //Callback event
            object.OnRender.Invoke(object, new AnimationArgs_1.AnimationArgs(interpolationValue));
            object.OnFrame.Invoke(object, new AnimationArgs_1.AnimationArgs(interpolationValue));
            //Finish
            if (object.currentFrame >= totalFrames)
                object.FinishAnimation(to);
        };
        animationFrame();
        return this;
    };
    /**
     * Method that handles animation finishing
     * @param to Target value
     */
    Animation.prototype.FinishAnimation = function (to) {
        this.OnRender.Invoke(this, new AnimationArgs_1.AnimationArgs(to));
        this.OnEnd.Invoke(this, new AnimationArgs_1.AnimationArgs(to));
    };
    /**
     * Stop and resets the current animation
     * */
    Animation.prototype.Stop = function () {
        if (this.frameTimeout != -1) {
            clearTimeout(this.frameTimeout);
            this.frameTimeout = -1;
        }
        this.currentFrame = 0;
        return this;
    };
    /**
     * Pauses the current animation
     * */
    Animation.prototype.Pause = function () {
        if (this.frameTimeout != -1) {
            clearTimeout(this.frameTimeout);
            this.frameTimeout = -1;
        }
        return this;
    };
    /**
     * Continues last paused animation (only if previous animation were played)
     * */
    Animation.prototype.Continue = function () {
        return this.Start(this.from, this.to);
    };
    return Animation;
}());
exports.Animation = Animation;
/*

 function Interpolate(from: number, to: number, lerp: ILerpFunction, callback: Function)
{
    //let interpolationValue = 0.01;
    let targetVal = to;
    let currentFrame = 0;
    let duration = 1000;
    let timeBetweenFrames = 10;

    let animationFrame = function ()
    {
        //console.log("Frame: " + currentFrame);

        currentFrame += timeBetweenFrames;
        let interpolationValue = lerp(from, targetVal, currentFrame, duration);

        //console.log("   value: " + interpolationValue);

        if (currentFrame < duration)
            setTimeout(animationFrame, timeBetweenFrames);
        else
            callback(interpolationValue);
    }
    animationFrame();
}

 
 */ 
